C题：给定一个长度为偶数n的字符串s。字符串s是二进制的，即只包含0和1。
字符串s恰好包含n/2个0和n/2个1（n是偶数）。
在一次操作中，你可以反转字符串s的任意子串。子串是字符串的一个连续子序列。
你需要进行多少次操作才能使字符串s交替？如果对于所有的i，都有si≠si+1，那么字符串就是交替的。交替字符串一般有两种类型：01010101...或10101010...
输入
第一行包含一个整数t（1≤t≤1000）——测试用例的数量。
每个测试用例的第一行包含一个整数n（2≤n≤10^5；n是偶数）——字符串s的长度。
每个测试用例的第二行包含一个长度为n的二进制字符串s（si∈{0, 1}）。字符串s恰好包含n/2个0和n/2个1。
保证所有测试用例中n的总和不超过10^5。
输出
对于每个测试用例，输出使s交替所需的最小操作次数。

D题：
在一家商店里有N个商品。对于每一个商品i（i=1,2,…,N），其价格都是A_i日元（日本的货币单位）。
高桥有K张优惠券。每张优惠券可以用在一个商品上。同一个商品可以使用任意数量的优惠券，包括零张。如果在一个价格为a日元的商品上使用k张优惠券，那么购买这个商品需要支付的金额将是max{a - kX, 0}日元，其中X是一个固定的值（这个值在问题描述中没有明确给出，但我们可以假设它是已知的）。
请打印出高桥购买所有商品所需支付的最小金额。

E题：
给定一个整数N，找到满足以下所有条件的最小整数X。
X大于或等于N。
存在一对非负整数(a, b)，使得X等于a^3 + a^2b + ab^2 + b^3。
F题：
Monocarp有一棵由n个顶点组成的树，且根节点为顶点1。他决定学习广度优先搜索（BFS），于是他从根节点开始对这棵树进行了BFS遍历。BFS的伪代码可以描述如下：
`a = [] # the order in which vertices were processed
q = Queue()
q.put(1) # place the root at the end of the queue
while not q.empty():
    k = q.pop() # retrieve the first vertex from the queue
    a.append(k) # append k to the end of the sequence in which vertices were visited
    for y in g[k]: # g[k] is the list of all children of vertex k, sorted in ascending order
        q.put(y)`
Monocarp对BFS如此着迷，以至于最后他失去了自己的树。幸运的是，他仍然记得BFS算法遍历顶点的顺序（即伪代码中的数组a）。Monocarp知道每个顶点只被访问了一次（因为它们被精确地放入和从队列中取出了一次）。他还知道每个顶点的所有子节点都是按照升序访问的。
Monocarp知道，具有相同访问顺序a的树（在一般情况下）有很多，所以他并不希望恢复原来的树。Monocarp接受任何具有最小高度的树。
树的高度是指树中顶点的最大深度，而顶点的深度是指从根节点到该顶点的路径上的边数。例如，顶点1的深度是0，因为它是根节点，所有根节点的子节点的深度都是1。
请帮助Monocarp找到具有给定访问顺序a和最小高度的任意一棵树。

G题：
我们有一个N×N的棋盘。用(i,j)表示从上往下数第i行、从左往右数第j列的格子。
棋盘由N个字符串S_i描述。字符串S_i的第j个字符S_{i,j}代表以下意义：

如果S_{i,j}是.，那么格子(i,j)是空的。
如果S_{i,j}是#，那么格子(i,j)被一个白色的兵占据，这个兵不能移动或移除。
我们在格子(A_x, A_y)上放置了一个白色的象。
根据国际象棋的规则（参见注释），找出将这个象从(A_x, A_y)移动到(B_x, B_y)所需的最小步数。
如果无法移动到(B_x, B_y)，则输出-1。
注释
在棋盘上的格子(i,j)上的白色象可以在一步内移动到以下位置：
对于每个正整数d，如果满足以下条件，它可以移动到(i+d,j+d)：
格子(i+d,j+d)在棋盘上。
对于每个正整数l≤d，(i+l,j+l)不被白色的兵占据。

对于每个正整数d，如果满足以下条件，它可以移动到(i+d,j-d)：
格子(i+d,j-d)在棋盘上。
对于每个正整数l≤d，(i+l,j-l)不被白色的兵占据。

对于每个正整数d，如果满足以下条件，它可以移动到(i-d,j+d)：
格子(i-d,j+d)在棋盘上。
对于每个正整数l≤d，(i-l,j+l)不被白色的兵占据。

对于每个正整数d，如果满足以下条件，它可以移动到(i-d,j-d)：
格子(i-d,j-d)在棋盘上。
对于每个正整数l≤d，(i-l,j-l)不被白色的兵占据。
2 ≤ N ≤ 1500
1 ≤ Ax, Ay ≤ N
1 ≤ Bx, By ≤ N
(Ax, Ay) ≠ (Bx, By)
Si 是一个长度为 N 的字符串，由 . 和 # 组成。
S{Ax, Ay} = .
S{Bx, By} = .

H题：
Monocarp厨师刚刚把n道菜肴放进了烤箱。他知道第i道菜肴的最佳烹饪时间是ti分钟。
在任何正整数分钟T，Monocarp最多只能从烤箱中拿出一道菜。如果第i道菜肴在某一分钟T被拿出，那么它的不愉快值就是|T-ti|——T和ti之间的绝对差值。一旦菜肴从烤箱中取出，就不能再放回去了。
Monocarp需要将所有的菜肴都从烤箱中取出。Monocarp能获得的最小总不愉快值是多少？
输入
第一行包含一个整数q（1≤q≤200）——测试用例的数量。
接下来是q个测试用例。
每个测试用例的第一行包含一个整数n（1≤n≤200）——烤箱中的菜肴数量。
每个测试用例的第二行包含n个整数t1,t2,…,tn（1≤ti≤n）——每道菜肴的最佳烹饪时间。
所有q个测试用例中n的总和不超过200。
输出
对于每个测试用例，输出一个整数——当Monocarp将所有菜肴从烤箱中取出时，他能获得的最小总不愉快值。请注意，Monocarp只能在正整数分钟取出菜肴，并且任何一分钟内最多只能取出一道菜。

下周目标：
复习dfs bfs 素数筛。
高数物理知识点复习，准备测试。
