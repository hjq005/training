**#题目翻译，部分理解**

**A - 营销计划**
你在一家宠物店找到了一份营销人员的工作，你目前的任务是促进猫粮的销售。其中一种策略是以折扣价出售包装食品罐头。
假设您决定出售带有 a包打折的罐头，一些顾客想买 x罐猫粮罐头. 然后他遵循贪婪的策略：
    他买 ⌊x/a⌋包打折套餐;
    然后他想买剩下的 (x%a)罐头一个接一个。
⌊x/a]是x除以 a四舍五入, x%a是x的剩余部分除以a.
但客户一般都是贪婪的，所以如果客户想买 (x%a)罐头 一个接一个，碰巧 (x%a)≥a/2 他决定买下整包 a罐 (而不是购买 (x%a)罐). 作为营销人员，它让您感到高兴，因为客户购买的比他最初想要的要多。
您知道，每个来到您商店的顾客都可以从中购买任意数量的罐头从l到r。 你能选择a大小的包装使一个每个客户购买的罐头都比他们最初想要的要多？
输入
第一行包含单个整数 t (1≤t≤1000) — 测试用例的数量.
每个测试用例的第一行也是唯一的一行包含两个整数 l和 r (1≤l≤r≤109) —客户可以购买的罐头数量范围。
输出
对于每个测试用例，打印 YES 如果可以选择这样的包装尺寸 a每个客户购买的罐头都比他们最初想要的要多。否则，请打印 NO.

      `if(l*2<=r)
	    	cout<<"NO"<<endl;
	    else
	    	cout<<"YES"<<endl;`
      
**C - 反向二进制字符串**
你会得到一个字符串 s偶数长度 n. 字符串 s是二进制的, 换言之,仅包含以下内容 0's 和 1's.
字符串 s 有确切的 n/2零和n/2一(n是偶数).
在一个操作中，您可以反转 s.字符串的子字符串是该字符串的连续子序列。
制作字符串所需的最小操作数是多少 s交替？如果 si≠si+1适合所有i. 通常有两种类型的交替字符串： 01010101... or 10101010...
`void solve(){
	int n,i;
	char s[N];
	cin>>n>>s;
	int n0=0,n1=0;
	for(i=1;i<n;i++)
	{
		if(s[i]==s[i-1])
		{
			if(s[i]=='0')
				n0++;
			else
				n1++;
		}
	}
	cout<<max(n0,n1)<<endl;
}
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		solve();
	}
		
	return 0;
}`

**D - 优惠券**
在一家商店里有N个商品。对于每一个商品i（i=1,2,…,N），其价格都是Ai日元（日本的货币单位）。
高桥有K张优惠券。每张优惠券可以用在一个商品上。同一个商品可以使用任意数量的优惠券，包括零张。如果在一个价格为a日元的商品上使用k张优惠券，那么购买这个商品需要支付的金额将是max{a - kX, 0}日元，其中X是一个固定的值（这个值在问题描述中没有明确给出，但我们可以假设它是已知的）。
请打印出高桥购买所有商品所需支付的最小金额。
 `int n,i;
	long long sum=0,z,k,x;
	cin>>n>>k>>x;
	for(i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]>=x&&k>0){
			z=a[i]/x;
			if(z<k){
				a[i]-=z*x;
				k-=z;
			}
			else{
				a[i]-=k*x;
				k=0;
			}
			
		}
		sum+=a[i];
	}
	if(k==0||sum==0)
		cout<<sum;
	else{
    	 sort(a,a+n+1);
    	for(i=n;i>0&&k>0;i--,k--)
	    	sum-=a[i];
     	cout<<sum;
	}`

 **E - 2 变量函数**
给定一个整数N，找到满足以下所有条件的最小整数X。
X大于或等于N。
存在一对非负整数(a, b)，使得X等于a^3 + a^2b + ab^2 + b^3。
0≤N≤10^18
理解：x=(a+b)*(a^2+b^2)>=(a+b)*2ab当且仅当a=b,所以x=4a^3,找a（0-10^6）二分算法

**F - 最小高度树 **
Monocarp有一棵由n个顶点组成的树，且根节点为顶点1。他决定学习广度优先搜索（BFS），于是他从根节点开始对这棵树进行了BFS遍历。BFS的伪代码可以描述如下：
`a = [] # the order in which vertices were processed
q = Queue()
q.put(1) # place the root at the end of the queue
while not q.empty():
    k = q.pop() # retrieve the first vertex from the queue
    a.append(k) # append k to the end of the sequence in which vertices were visited
    for y in g[k]: # g[k] is the list of all children of vertex k, sorted in ascending order
        q.put(y)`
        
Monocarp对BFS如此着迷，以至于最后他失去了自己的树。幸运的是，他仍然记得BFS算法遍历顶点的顺序（即伪代码中的数组a）。Monocarp知道每个顶点只被访问了一次（因为它们被精确地放入和从队列中取出了一次）。他还知道每个顶点的所有子节点都是按照升序访问的。
Monocarp知道，具有相同访问顺序a的树（在一般情况下）有很多，所以他并不希望恢复原来的树。Monocarp接受任何具有最小高度的树。
树的高度是指树中顶点的最大深度，而顶点的深度是指从根节点到该顶点的路径上的边数。例如，顶点1的深度是0，因为它是根节点，所有根节点的子节点的深度都是1。
请帮助Monocarp找到具有给定访问顺序a和最小高度的任意一棵树。

**G - 主教 2**
我们有一个N×N的棋盘。用(i,j)表示从上往下数第i行、从左往右数第j列的格子。
棋盘由N个字符串S_i描述。字符串S_i的第j个字符S_{i,j}代表以下意义：

如果S_{i,j}是.，那么格子(i,j)是空的。
如果S_{i,j}是#，那么格子(i,j)被一个白色的兵占据，这个兵不能移动或移除。
我们在格子(A_x, A_y)上放置了一个白色的象。
根据国际象棋的规则（参见注释），找出将这个象从(A_x, A_y)移动到(B_x, B_y)所需的最小步数。
如果无法移动到(B_x, B_y)，则输出-1。

注释
在棋盘上的格子(i,j)上的白色象可以在一步内移动到以下位置：
对于每个正整数d，如果满足以下条件，它可以移动到(i+d,j+d)：
格子(i+d,j+d)在棋盘上。
对于每个正整数l≤d，(i+l,j+l)不被白色的兵占据。

对于每个正整数d，如果满足以下条件，它可以移动到(i+d,j-d)：
格子(i+d,j-d)在棋盘上。
对于每个正整数l≤d，(i+l,j-l)不被白色的兵占据。

对于每个正整数d，如果满足以下条件，它可以移动到(i-d,j+d)：
格子(i-d,j+d)在棋盘上。
对于每个正整数l≤d，(i-l,j+l)不被白色的兵占据。

对于每个正整数d，如果满足以下条件，它可以移动到(i-d,j-d)：
格子(i-d,j-d)在棋盘上。
对于每个正整数l≤d，(i-l,j-l)不被白色的兵占据。
2 ≤ N ≤ 1500
1 ≤ Ax, Ay ≤ N
1 ≤ Bx, By ≤ N
(Ax, Ay) ≠ (Bx, By)
Si 是一个长度为 N 的字符串，由 . 和 # 组成。
S{Ax, Ay} = .
S{Bx, By} = .

**H - 首席单果皮**
Monocarp厨师刚刚把n道菜肴放进了烤箱。他知道第i道菜肴的最佳烹饪时间是ti分钟。
在任何正整数分钟T，Monocarp最多只能从烤箱中拿出一道菜。如果第i道菜肴在某一分钟T被拿出，那么它的不愉快值就是|T-ti|——T和ti之间的绝对差值。一旦菜肴从烤箱中取出，就不能再放回去了。
Monocarp需要将所有的菜肴都从烤箱中取出。Monocarp能获得的最小总不愉快值是多少？
输入
第一行包含一个整数q（1≤q≤200）——测试用例的数量。
接下来是q个测试用例。
每个测试用例的第一行包含一个整数n（1≤n≤200）——烤箱中的菜肴数量。
每个测试用例的第二行包含n个整数t1,t2,…,tn（1≤ti≤n）——每道菜肴的最佳烹饪时间。
所有q个测试用例中n的总和不超过200。
输出
对于每个测试用例，输出一个整数——当Monocarp将所有菜肴从烤箱中取出时，他能获得的最小总不愉快值。请注意，Monocarp只能在正整数分钟取出菜肴，并且任何一分钟内最多只能取出一道菜。
